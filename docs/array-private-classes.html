<ul>
<li>Feature Name: array_private_classes</li>
<li>Start Date: 2022-01-08</li>
<li>RFC PR: (leave this empty)</li>
<li>Pony Issue: (leave this empty)</li>
</ul>
<h1 id="summary">Summary</h1>
<p>Collection classes should not expose internal classes through iterators functions.</p>
<p>Following information hiding design principle, the builtin classes of collection data structures must not be made visible through iterator functions like <code>ArrayKeys</code>, <code>ArrayValues</code> and <code>ArrayPairs</code>. These classes can be made private as they are only used as return types for <code>Array</code> functions <code>keys</code>, <code>values</code> and <code>pairs</code>. The return values for these functions are changed to the more general interface <code>Iterator</code>.</p>
<p>A new interface <code>CollectionIterator</code> is defined to allow for rewindable iterators, like it is the case for <code>Array</code> <code>values</code>.</p>
<p>This design principle is applied to the other collection classes that expose internals too like:</p>
<ul>
<li><code>List</code></li>
<li><code>Map</code></li>
<li>persistent <code>Map</code></li>
<li><code>Vec</code></li>
<li>persistent <code>Vec</code></li>
<li><code>Set</code></li>
<li><code>Itertools</code></li>
</ul>
<p>This is a breaking change for collections' client code that use now internal classes but a search on Github repositories shows that the impact should be limited.</p>
<h1 id="motivation">Motivation</h1>
<p>This change brings:</p>
<ul>
<li>Applying the design principle of <a href="https://en.wikipedia.org/wiki/Information_hiding">hiding implementation details</a> but offer a general and stable interface. Returning interfaces instead of concrete classes allows changing the implementation. Usually, one must return the most general type that fullfils the contract of the function (in the case of the functions discussed in this RFC, iteration).</li>
<li>Collections' functions <code>keys</code>, <code>values</code> and <code>pairs</code> definitions are made more general. Iterators implementation details are not public. Internal classes used by implementation like <code>*Keys</code>, <code>*Values</code> and <code>*Pairs</code> are now <a href="https://en.wikipedia.org/wiki/Opaque_data_type">opaque data types</a>. Generally, when using these collection classes, clients are not interested by the iterators implementation, but by the types these iterators return and that is provided by the generic parameters.</li>
<li>The generic return signature of these 3 iterating functions is simpler to understand for clients of collection classes.</li>
<li>Reduces the number of public classes in the standard library by hiding 18 specialised classes (iterators implementations) of which 3 are from the <code>builtin</code> module.</li>
<li>The interface <code>CollectionIterator</code> is added to create rewindable iterators (can be re-start from first value).</li>
</ul>
<p>This change remains compatible with the existing code base but for client code that is directly using the classes <code>*Keys</code>, <code>*Values</code> and <code>*Pairs</code>. A search on Github shows that the impact is very limited.</p>
<p>To quote Antoine de Saint-Exup√©ry:</p>
<blockquote>
<p>Perfection is achieved, not when there is nothing more to add, but when there is nothing left to take away.</p>
</blockquote>
<p>Currently the API makes a guarantee that the return value of each of these functions is a specific concrete class with a specific public name. That particular guarantee does not actually serve any practical needs of users (except, arguably, the virtual calls caveat that was mentioned on <a href="https://github.com/ponylang/rfcs/pull/193#issuecomment-1009733064">Github discussion</a>). If it is not helpful to users in practice, it can be removed. And if it can be removed, then it should be removed, in the name of taking another step toward stabilizing the Pony standard library's API.</p>
<p>It's worth mentioning that if this change was being debated in reverse (the current standard library had minimal interfaces for the return values, and somebody proposed to make them public concrete classes instead, because they found some tangible benefit in doing so), then it would not be a breaking change at all, because the new proposed type would be a subtype of the existing return types.</p>
<p>It'll always be easier to get more specific with these return types than more general. So we should default to offering the most general return type that is still useful to users, and ratchet down to more specific subtypes as needed (as tangible use cases for more specific return types are discovered). Ratcheting down will always be possible without a breaking change, but ratcheting up will be a breaking change each time. It's best to make such "ratchet up" breaking changes like this RFC before we reach Pony 1.0.0 as part of a general effort to make Pony and its standard library stable.</p>
<h1 id="detailed-design">Detailed design</h1>
<p>Iterating functions in collections <code>keys</code>, <code>values</code> and <code>pairs</code> are changed to return <code>Iterator</code> and the classes that implement these iterators are made private. Here are the full implementation of these functions for the <code>Array</code> class (changes in other collection classes are identical).</p>
<p>As the function <code>values</code> of class <code>Array</code> uses an iterator with a <code>rewind</code> function that is not part of the <code>Iterator</code> interface, a new interface <code>CollectionIterator</code> is added to enable creation of rewindable iterators.</p>
<pre class="pony"><code>  fun keys(): CollectionIterator[USize]^ =&gt;
    &quot;&quot;&quot;
    Return an iterator over the indices in the array.
    &quot;&quot;&quot;
    _ArrayKeys[A, this-&gt;Array[A]](this)

  fun values(): CollectionIterator[this-&gt;A]^ =&gt;
    &quot;&quot;&quot;
    Return an iterator over the values in the array.
    &quot;&quot;&quot;
    _ArrayValues[A, this-&gt;Array[A]](this)

  fun pairs(): CollectionIterator[(USize, this-&gt;A)]^ =&gt;
    &quot;&quot;&quot;
    Return an iterator over the (index, value) pairs in the array.
    &quot;&quot;&quot;
    _ArrayPairs[A, this-&gt;Array[A]](this)
</code></pre>
<p>Note: To remain consistent with <code>Array</code> behaviour, functions <code>keys</code> and <code>pairs</code> will return a <code>CollectionIterator</code>.</p>
<pre class="pony"><code>interface CollectionIterator[A] is Iterator[A]
  &quot;&quot;&quot;
  A `CollectionIterator` is an iterator that can be rewinded, that is start
  again from first item. The data structure being iterated on can&#39;t change the
  order it return iterated items.
  &quot;&quot;&quot;
  fun has_next(): Bool
    &quot;&quot;&quot;
    Return `true` when function `next` can be called to get next iteration item.
    &quot;&quot;&quot;

  fun ref next(): A ?
    &quot;&quot;&quot;
    Return the next item of the iteration or an error in case there are no other
    items. A previous call to `has_next` check if we can continue iteration.
    &quot;&quot;&quot;

  fun ref rewind(): Iterator[A]^
    &quot;&quot;&quot;
    Start the iterator over again from the beginning.
    &quot;&quot;&quot;
</code></pre>
<p>The code of the standard library is adapted to remove use of these now private classes, mainly in tests. Here are the files that must be changed:</p>
<ul>
<li><code>packages/builtin/array.pony</code> as shown above</li>
<li><code>packages/itertools/iter.pony</code> in function <code>cycle</code></li>
<li><code>packages/collections/heap.pony</code> in function <code>values</code></li>
<li><code>packages/collection/builtin/_test.pony</code> in class <code>_TestArrayValuesRewind</code></li>
<li><code>packages/collections/list.pony</code></li>
<li><code>packages/collections/map.pony</code></li>
<li><code>packages/collections/persistent/map.pony</code></li>
<li><code>packages/collections/persistent/vec.pony</code></li>
<li><code>packages/collections/set.pony</code></li>
<li><code>test/libponyc/util.cc</code> to change the name of the class to <code>_ArrayValues</code></li>
</ul>
<h2 id="detailed-changes">Detailed changes</h2>
<p>In order to judge how the API becomes simpler to understand for clients of the collections classes, here are the changes in the functions' signatures. The <code>-</code> line shows the old signature while the <code>+</code> one is the new:</p>
<pre class="pony"><code>// Array
-  fun keys(): ArrayKeys[A, this-&gt;Array[A]]^ =&gt;
+  fun keys(): Iterator[USize]^ =&gt;
-  fun values(): ArrayValues[A, this-&gt;Array[A]]^ =&gt;
+  fun values(): CollectionIterator[this-&gt;A]^ =&gt;
-  fun pairs(): ArrayPairs[A, this-&gt;Array[A]]^ =&gt;
+  fun pairs(): Iterator[(USize, this-&gt;A)]^ =&gt;

// Heap
-  fun values(): ArrayValues[A, this-&gt;Array[A]]^ =&gt;
+  fun values(): Iterator[this-&gt;A]^ =&gt;

// List
-  fun nodes(): ListNodes[A, this-&gt;ListNode[A]]^ =&gt;
+  fun nodes(): Iterator[this-&gt;ListNode[A]]^ =&gt;
-  fun rnodes(): ListNodes[A, this-&gt;ListNode[A]]^ =&gt;
+  fun rnodes(): Iterator[this-&gt;ListNode[A]]^ =&gt;
-  fun values(): ListValues[A, this-&gt;ListNode[A]]^ =&gt;
+  fun values(): Iterator[this-&gt;A]^ =&gt;
-  fun rvalues(): ListValues[A, this-&gt;ListNode[A]]^ =&gt;
+  fun rvalues(): Iterator[this-&gt;A]^ =&gt;

// Map
-  fun keys(): MapKeys[K, V, H, this-&gt;HashMap[K, V, H]]^ =&gt;
+  fun keys(): Iterator[this-&gt;K]^ =&gt;
-  fun values(): MapValues[K, V, H, this-&gt;HashMap[K, V, H]]^ =&gt;
+  fun values(): Iterator[this-&gt;V]^ =&gt;
-  fun pairs(): MapPairs[K, V, H, this-&gt;HashMap[K, V, H]]^ =&gt;
+  fun pairs(): Iterator[(this-&gt;K, this-&gt;V)]^ =&gt;

// Persistent Map
-  fun val keys(): MapKeys[K, V, H] =&gt;
+  fun val keys(): Iterator[K] =&gt;
-  fun val values(): MapValues[K, V, H] =&gt;
+  fun val values(): Iterator[V] =&gt;
-  fun val pairs(): MapPairs[K, V, H] =&gt;
+  fun val pairs(): Iterator[(K, V)] =&gt;

// Persistent Vec
-  fun val keys(): VecKeys[A]^ =&gt;
+  fun val keys(): Iterator[USize]^ =&gt;
-  fun val values(): VecValues[A]^ =&gt;
+  fun val values(): Iterator[A]^ =&gt;
-  fun val pairs(): VecPairs[A]^ =&gt;
+  fun val pairs(): Iterator[(USize, A)]^ =&gt;

// Set
-  fun values(): SetValues[A, H, this-&gt;HashSet[A, H]]^ =&gt;
+  fun values(): Iterator[this-&gt;A]^ =&gt;
</code></pre>
<p>For instance, in <code>Array</code></p>
<pre class="pony"><code>-  fun keys(): ArrayKeys[A, this-&gt;Array[A]]^ =&gt;
+  fun keys(): Iterator[USize]^ =&gt;
</code></pre>
<p>now the client user knows now that she gets an iterator over <code>USize</code>.</p>
<p>Another more complex example with <code>Map</code>,</p>
<pre class="pony"><code>-  fun keys(): MapKeys[K, V, H, this-&gt;HashMap[K, V, H]]^ =&gt;
+  fun keys(): Iterator[this-&gt;K]^ =&gt;
-  fun values(): MapValues[K, V, H, this-&gt;HashMap[K, V, H]]^ =&gt;
+  fun values(): Iterator[this-&gt;V]^ =&gt;
</code></pre>
<p>we see that we iterate over keys (<code>K</code> type) or values (<code>V</code>). The initial signature gave complex generic classes that the user has to find in the documentation to understand that they are iterators, and then dive deeper to understand on what they iterate.</p>
<h1 id="how-we-teach-this">How We Teach This</h1>
<p>This change keeps the code compatible in the vast majority of cases. When client classes are defining objects of these now private types, the reason is usually to get access to the function <code>rewind</code> that was not defined in <code>Iterator</code>. By adding the interface <code>CollectionIterator</code>, client code can easily be adapted, replacing <code>ArrayValues[A]</code> by <code>CollectionIterator[A]</code>.</p>
<p>Also, client code generally uses these functions to iterate on the returned types and does not try to access the iterator directly but is interested by the iterated items. When client code refers to the iterator type, that's generally useless and the code can be rewritten to be made shorter and more future proof.</p>
<p>A <a href="https://github.com/search?q=%22ArrayValues%22+language%3APony&amp;type=code">search on Github Pony code</a> finds 24 files using the class <code>ArrayValues</code>, of which 6 are copies of <code>array.pony</code> file.</p>
<p>For instance, in <a href="https://github.com/redvers/pony-libxml2/blob/bbca5d98d48854bfec2c6ee110220873ecc4df34/pony-libxml2/xml2xpath.pony#L41">xml2xpath.pony</a>, the code can be changed from</p>
<pre class="pony"><code>  fun values(): ArrayValues[Xml2node, this-&gt;Array[Xml2node]]^ ? =&gt;
    if (allocated) then
      ArrayValues[Xml2node, this-&gt;Array[Xml2node]](nodearray)
    else
      error
    end
</code></pre>
<p>to</p>
<pre class="pony"><code>  fun values(): CollectionIterator[Xml2node]^ ? =&gt;
    if (allocated) then
      nodearray.values()
    else
      error
    end
</code></pre>
<p>In this sample, the developer was not really concerned by the type of the iterator but that the <code>values</code> function must return an <code>CollectionIterator</code> over <code>Xml2node</code>. The new version makes the code simpler to understand.</p>
<p>This change in <code>array.pony</code> and other collections will break such code but it can be easily adapted to use the new API. And it will make the standard library easier to learn by reducing the number of public types.</p>
<h1 id="how-we-test-this">How We Test This</h1>
<p>Pony tests must continue to pass. No additional tests are need as after review the existing coverage in Pony standard library tests is sufficient</p>
<h1 id="drawbacks">Drawbacks</h1>
<p>Will break any existing code that uses any of the classes that are currently public and will be made private by this RFC.</p>
<h1 id="alternatives">Alternatives</h1>
<ol>
<li><p>Stay as is. Continue the <a href="https://ponylang.zulipchat.com/#narrow/stream/189959-RFCs/topic/Make.20Array.20iterators.20private">discussion on Zulip</a>.</p></li>
<li><p>Update the existing concrete classes to include <code>rewind</code> where needed.</p></li>
<li><p>Instead of defining a new type of iterator with the <code>CollectionIterator</code> interface, we can consider only the rewindable part of it in an <code>Rewindable</code> interface:</p></li>
</ol>
<pre class="pony"><code>interface Rewindable[A]
  fun ref rewind(): A^
    &quot;&quot;&quot;
    Rewind the type `A`.
    &quot;&quot;&quot;
</code></pre>
<p>Then one can create a rewindable iterator by combining these two interfaces:</p>
<pre class="pony"><code>type CollectionIterator[A] is (Iterator[A] &amp; Rewindable[Iterator[A]])
</code></pre>
<p>Perhaps, a more general interface name instead of <code>Rewindable</code> would be <code>Resetable</code> to define the traits of a type that can be reset to its initial state, as in the case of iterators <code>reset</code> == <code>rewind</code>.</p>
<p>The rewindable type can be used with other types than <code>Iterator</code>, like a data structure that would implement a rewindable property. This alternative was <a href="https://github.com/ponylang/rfcs/pull/193#discussion_r780793165">put aside</a> to prevent name colisions in <code>builtin</code> with user-named types.</p>
<h2 id="comparison-of-alternatives">Comparison of alternatives</h2>
<ol>
<li>Do nothing: return public concrete classes.</li>
<li>Update the existing return classes and add <code>rewind</code>.</li>
<li>Add a <code>CollectionIterator</code> interface for collections.</li>
<li>Create union type by defining a <code>Rewindable</code> interface and combine with <code>Iterator</code>.</li>
<li>Change <code>Iterator</code> to add <code>rewind</code>.</li>
</ol>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Justification / Alternative #</th>
<th style="text-align: center;">1</th>
<th style="text-align: center;">2</th>
<th style="text-align: center;">3</th>
<th style="text-align: center;">4</th>
<th style="text-align: center;">5</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">a. Simpler stdlib API</td>
<td style="text-align: center;">---</td>
<td style="text-align: center;">---</td>
<td style="text-align: center;">+</td>
<td style="text-align: center;">+++</td>
<td style="text-align: center;">+++</td>
</tr>
<tr class="even">
<td style="text-align: left;">b. Simpler function signatures</td>
<td style="text-align: center;">---</td>
<td style="text-align: center;">---</td>
<td style="text-align: center;">+</td>
<td style="text-align: center;">+++</td>
<td style="text-align: center;">+++</td>
</tr>
<tr class="odd">
<td style="text-align: left;">c. Stay compatible with existing stdlib</td>
<td style="text-align: center;">+++</td>
<td style="text-align: center;">+++</td>
<td style="text-align: center;">+</td>
<td style="text-align: center;">+++</td>
<td style="text-align: center;">+</td>
</tr>
<tr class="even">
<td style="text-align: left;">d. Evolutive</td>
<td style="text-align: center;">---</td>
<td style="text-align: center;">+</td>
<td style="text-align: center;">+++</td>
<td style="text-align: center;">+++</td>
<td style="text-align: center;">+</td>
</tr>
<tr class="odd">
<td style="text-align: left;">e. No impact on compiler</td>
<td style="text-align: center;">+++</td>
<td style="text-align: center;">+++</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">+++</td>
<td style="text-align: center;">-</td>
</tr>
<tr class="even">
<td style="text-align: left;">f. No impact on performance</td>
<td style="text-align: center;">+++</td>
<td style="text-align: center;">+++</td>
<td style="text-align: center;">+++</td>
<td style="text-align: center;">+++</td>
<td style="text-align: center;">+++</td>
</tr>
<tr class="odd">
<td style="text-align: left;">g. Limit stdlib pollution with interfaces</td>
<td style="text-align: center;">+++</td>
<td style="text-align: center;">+++</td>
<td style="text-align: center;">+</td>
<td style="text-align: center;">+</td>
<td style="text-align: center;">+++</td>
</tr>
<tr class="even">
<td style="text-align: left;">g. Limit stdlib pollution with classes</td>
<td style="text-align: center;">---</td>
<td style="text-align: center;">---</td>
<td style="text-align: center;">+++</td>
<td style="text-align: center;">++</td>
<td style="text-align: center;">+++</td>
</tr>
</tbody>
</table>
<h1 id="unresolved-questions">Unresolved questions</h1>
<ul>
<li>Must analyze how <code>Range</code> and <code>Reverse</code> would be impacted if defined as <code>CollectionIterator</code>. Particularly, impact on existing client code.</li>
<li>Possible candidates to be analyzed: <code>StringBytes</code>, <code>StringRunes</code>, <code>ByteSeqIter</code> and probably others will be found in code.</li>
</ul>
